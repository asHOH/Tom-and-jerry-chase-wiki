<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="robots" content="noindex, nofollow" />
    <title>衍生物编辑器</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #f7f7fa;
        --card: #ffffff;
        --border: #d7d7e3;
        --text: #1c1c28;
        --muted: #5a6072;
        --primary: #315efb;
        --primary-text: #ffffff;
        --danger: #d93025;
        --shadow: 0 12px 32px rgba(0, 0, 0, 0.12);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #111318;
          --card: #1c1f24;
          --border: #2a2e36;
          --text: #f5f6fb;
          --muted: #a0a5b5;
          --primary: #7295ff;
          --primary-text: #0b1228;
          --danger: #ff6b6b;
          --shadow: 0 12px 32px rgba(0, 0, 0, 0.32);
        }
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.6;
      }

      a {
        color: inherit;
      }

      .container {
        max-width: 1048px;
        margin: 0 auto;
        padding: 32px 20px 96px;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 24px;
        border-radius: 20px;
        background: var(--card);
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      header h1 {
        margin: 0;
        font-size: 1.75rem;
        font-weight: 700;
      }

      header p {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      button {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 10px 18px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition:
          transform 0.15s ease,
          box-shadow 0.2s ease,
          background 0.2s ease;
        background: var(--card);
        border: 1px solid var(--border);
        color: var(--text);
      }

      button.primary {
        background: var(--primary);
        border-color: var(--primary);
        color: var(--primary-text);
      }

      button.ghost {
        background: transparent;
      }

      button.danger {
        background: transparent;
        border-color: var(--danger);
        color: var(--danger);
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 22px rgba(0, 0, 0, 0.07);
      }

      .entity-card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 20px;
        box-shadow: var(--shadow);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        transition:
          border-color 0.2s ease,
          transform 0.2s ease;
      }

      .entity-card:not(.collapsed):hover {
        transform: translateY(-2px);
      }

      .entity-card.has-error {
        border-color: var(--danger);
      }

      .card-header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 16px 20px;
        border-bottom: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.02);
      }

      .card-title {
        font-weight: 600;
        font-size: 1.05rem;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(49, 94, 251, 0.12);
        color: var(--primary);
        font-size: 0.78rem;
        font-weight: 600;
      }

      .card-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .card-body {
        padding: 20px;
      }

      .grid {
        display: grid;
        gap: 18px;
      }

      @media (min-width: 720px) {
        .grid.two {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      @media (min-width: 960px) {
        .grid.two {
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }
      }

      .field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .field label {
        font-weight: 600;
        font-size: 0.9rem;
      }

      .field small {
        color: var(--muted);
        font-size: 0.75rem;
      }

      input[type='text'],
      input[type='number'],
      select,
      textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.02);
        font-size: 0.95rem;
        color: var(--text);
        transition:
          border-color 0.2s ease,
          box-shadow 0.2s ease;
        font-family: inherit;
      }

      select[multiple] {
        min-height: 140px;
      }

      textarea {
        min-height: 110px;
        resize: vertical;
      }

      input:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(49, 94, 251, 0.16);
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .export-card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 20px;
        box-shadow: var(--shadow);
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .export-card h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      #exportOutput {
        font-family: 'Fira Code', 'Cascadia Code', 'SFMono-Regular', Consolas, monospace;
        min-height: 180px;
        white-space: pre;
      }

      .status-text {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .collapsed .card-body {
        display: none;
      }

      .collapsed .card-header {
        border-bottom: none;
      }

      .toast {
        position: fixed;
        bottom: 24px;
        right: 24px;
        padding: 12px 16px;
        border-radius: 12px;
        background: var(--text);
        color: var(--card);
        font-size: 0.9rem;
        display: none;
        z-index: 20;
      }

      .toast.show {
        display: block;
        animation: fadeInOut 2.4s ease forwards;
      }

      @keyframes fadeInOut {
        0% {
          opacity: 0;
          transform: translateY(6px);
        }
        8%,
        82% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(10px);
        }
      }

      .optional-group {
        padding: 18px;
        border-radius: 16px;
        border: 1px dashed var(--border);
        background: rgba(0, 0, 0, 0.02);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .optional-group h3 {
        margin: 0;
        font-size: 1rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        padding: 2px 10px;
        font-size: 0.75rem;
        background: rgba(26, 86, 219, 0.14);
        color: var(--primary);
      }

      footer {
        text-align: center;
        font-size: 0.8rem;
        color: var(--muted);
        padding-bottom: 36px;
      }

      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 12px;
        padding: 64px 16px;
        text-align: center;
        border-radius: 20px;
        border: 1px dashed var(--border);
        color: var(--muted);
      }

      .empty-state strong {
        font-size: 1.05rem;
        color: var(--text);
      }

      dialog {
        border: none;
        border-radius: 20px;
        padding: 0;
        max-width: min(760px, 90vw);
        width: min(760px, 90vw);
      }

      dialog::backdrop {
        background: rgba(0, 0, 0, 0.45);
      }

      .import-dialog {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 24px;
        background: var(--card);
        color: var(--text);
      }

      .import-dialog h2 {
        margin: 0;
        font-size: 1.25rem;
      }

      .import-dialog textarea {
        min-height: 260px;
        font-family: 'Fira Code', 'Cascadia Code', 'SFMono-Regular', Consolas, monospace;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>衍生物编辑器</h1>
        <p>编写或修改衍生物定义。数据仅保存在本地浏览器。暂时只支持导入单个衍生物。</p>
        <div class="toolbar">
          <button id="addEntity" class="primary" type="button">新增衍生物</button>
          <button id="expandAll" type="button">全部展开</button>
          <button id="collapseAll" type="button">全部收起</button>
          <button id="resetAll" class="danger" type="button">清空全部</button>
          <button id="importPaste" type="button">粘贴导入</button>
          <button id="importFile" type="button">文件导入</button>
          <button id="importExisting" type="button">导入站内全部衍生物</button>
          <span id="stats" class="status-text"></span>
        </div>
      </header>

      <div id="entitiesContainer" class="stack"></div>

      <section id="emptyState" class="empty-state" hidden>
        <strong>暂时没有衍生物</strong>
        <button id="emptyAdd" class="primary" type="button">添加新衍生物</button>
      </section>

      <section class="export-card">
        <h2>导出结果</h2>
        <div class="field">
          <label for="exportOutput">导出代码片段</label>
          <textarea id="exportOutput" readonly spellcheck="false"></textarea>
        </div>
        <div class="toolbar">
          <button id="copyBtn" class="primary" type="button">复制到剪贴板</button>
          <button id="downloadBtn" type="button">下载为 TXT</button>
          <span id="exportStatus" class="status-text"></span>
        </div>
      </section>

      <input id="importFileInput" type="file" accept=".ts,.tsx,.js,.jsx,.json,.txt" hidden />

      <dialog id="importDialog">
        <div class="import-dialog">
          <h2>粘贴代码导入</h2>
          <p class="status-text">支持直接粘贴衍生物定义或编辑器导出的片段。</p>
          <textarea
            id="importTextarea"
            spellcheck="false"
            placeholder="将衍生物定义粘贴在此处"
          ></textarea>
          <div class="toolbar">
            <button id="importCancel" type="button">取消</button>
            <button id="importConfirm" type="button" class="primary">导入</button>
          </div>
        </div>
      </dialog>
    </div>

    <template id="entityTemplate">
      <article class="entity-card" data-id="">
        <div class="card-header">
          <div class="card-title">
            <span class="badge">衍生物</span>
            <span data-role="title">未命名衍生物</span>
          </div>
          <div class="card-actions">
            <button type="button" class="ghost" data-action="toggle">折叠</button>
            <button type="button" class="ghost" data-action="export">剪切板导出</button>
            <button type="button" class="ghost" data-action="duplicate">复制</button>
            <button type="button" class="danger" data-action="delete">删除</button>
          </div>
        </div>
        <div class="card-body">
          <div class="stack">
            <div class="grid two">
              <div class="field">
                <label for="name">衍生物名称 *</label>
                <input
                  data-field="name"
                  type="text"
                  inputmode="text"
                  placeholder="例如：煎蛋"
                  autocomplete="off"
                />
              </div>
              <div class="field">
                <label>衍生物类型 *</label>
                <select data-field="entitytype" multiple>
                  <option value="道具类">道具类</option>
                  <option value="投射物">投射物</option>
                  <option value="召唤物">召唤物</option>
                  <option value="平台类">平台类</option>
                  <option value="NPC">NPC</option>
                  <option value="变身类">变身类</option>
                  <option value="指示物">指示物</option>
                </select>
                <small>可多选；至少选择一个；电脑端按住 Ctrl 或 Shift 进行多选。</small>
              </div>
              <div class="field">
                <label>阵营归属</label>
                <select data-field="factionId">
                  <option value="">（可选）</option>
                  <option value="cat">猫阵营</option>
                  <option value="mouse">鼠阵营</option>
                </select>
                <small>可不填，不填写时将继承所有者的阵营信息。</small>
              </div>
              <div class="field">
                <label>别名列表</label>
                <input data-field="aliasesInput" type="text" placeholder="使用逗号分隔多个别名" />
              </div>
            </div>

            <div class="optional-group">
              <h3>所有者信息</h3>
              <div class="grid two">
                <div class="field">
                  <label>所有者名称</label>
                  <input data-field="ownerName" type="text" placeholder="例如：手型枪" />
                </div>
                <div class="field">
                  <label>所有者类别</label>
                  <select data-field="ownerType">
                    <option value="">（未设置）</option>
                    <option value="character">角色</option>
                    <option value="skill">角色-技能</option>
                    <option value="knowledgeCard">知识卡</option>
                    <option value="specialSkill">特技</option>
                    <option value="item">道具</option>
                    <option value="entity">衍生物</option>
                    <option value="buff">状态</option>
                  </select>
                </div>
                <div class="field">
                  <label>所有者阵营</label>
                  <select data-field="ownerFactionId">
                    <option value="">（可选）</option>
                    <option value="cat">猫阵营</option>
                    <option value="mouse">鼠阵营</option>
                  </select>
                  <small>用于区分同名特技。其余情况可不填，会自动检索阵营信息。</small>
                </div>
              </div>
            </div>

            <div class="optional-group">
              <h3>移动信息</h3>
              <div class="grid two">
                <div class="field">
                  <label>会移动</label>
                  <select data-field="move" data-type="boolean">
                    <option value="">（未设置）</option>
                    <option value="true">是</option>
                    <option value="false">否</option>
                  </select>
                  <small>若物体可主动运动或可被其它效果被动推动，则填“是”，反之则填“否”。</small>
                </div>
                <div class="field">
                  <label>受重力影响</label>
                  <select data-field="gravity" data-type="boolean">
                    <option value="">（未设置）</option>
                    <option value="true">是</option>
                    <option value="false">否</option>
                  </select>
                  <small>若物体悬空时会自行下坠，则填“是”，反之则填“否”。</small>
                </div>
                <div class="field">
                  <label>碰撞对象</label>
                  <input
                    data-field="collsionInput"
                    type="text"
                    placeholder="逗号或换行分隔，例如：道具, 墙壁, 平台"
                  />
                  <small>建议按顺序填写以下符合条件的内容：角色，道具, 墙壁, 平台，地面。</small>
                </div>
              </div>
            </div>

            <div class="optional-group">
              <h3>文本描述</h3>
              <div class="grid">
                <div class="field">
                  <label>简明描述</label>
                  <textarea
                    data-field="description"
                    placeholder="支持特殊文本语法，包括[]()添加注释，{}添加站内链接等。下同"
                  ></textarea>
                </div>
                <div class="field">
                  <label>详细描述</label>
                  <textarea
                    data-field="detailedDescription"
                    placeholder="可不填，默认与简明描述相同。"
                  ></textarea>
                </div>
                <div class="field">
                  <label>简明产生方式</label>
                  <textarea data-field="create"></textarea>
                </div>
                <div class="field">
                  <label>详细产生方式</label>
                  <textarea
                    data-field="detailedCreate"
                    placeholder="可不填，默认与简明产生方式相同。"
                  ></textarea>
                </div>
              </div>
            </div>

            <div class="optional-group">
              <h3>附加代码 <span class="pill">请保持 TypeScript 语法</span></h3>
              <div class="field">
                <label>额外字段（可选）</label>
                <textarea
                  data-field="extraCode"
                  placeholder="用于添加衍生物技能或特殊属性等复杂字段，可不填。"
                ></textarea>
              </div>
            </div>
          </div>
        </div>
      </article>
    </template>

    <div id="toast" class="toast"></div>

    <script>
      const entities = [];
      const entitiesContainer = document.getElementById('entitiesContainer');
      const exportOutput = document.getElementById('exportOutput');
      const exportStatus = document.getElementById('exportStatus');
      const stats = document.getElementById('stats');
      const toast = document.getElementById('toast');
      const emptyState = document.getElementById('emptyState');
      const importPasteBtn = document.getElementById('importPaste');
      const importFileBtn = document.getElementById('importFile');
      const importExistingBtn = document.getElementById('importExisting');
      const importFileInput = document.getElementById('importFileInput');
      const importDialog = document.getElementById('importDialog');
      const importTextarea = document.getElementById('importTextarea');
      const importConfirm = document.getElementById('importConfirm');
      const importCancel = document.getElementById('importCancel');
      let isBulkUpdating = false;
      const STORAGE_KEY = 'tjwiki-entity-maker-v1';

      const booleanFields = ['move', 'gravity'];
      const textFields = ['description', 'detailedDescription', 'create', 'detailedCreate'];

      const defaultValues = {
        name: '',
        entitytype: ['召唤物'],
        factionId: '',
        ownerName: '',
        ownerType: '',
        ownerFactionId: '',
        aliasesInput: '',
        collsionInput: '',
        description: '',
        detailedDescription: '',
        create: '',
        detailedCreate: '',
        move: null,
        gravity: null,
        extraCode: '',
      };

      function generateId() {
        if (window.crypto && crypto.randomUUID) {
          return crypto.randomUUID();
        }
        return 'id-' + Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
      }

      function normalizeEntityType(raw) {
        if (Array.isArray(raw)) return raw.filter(Boolean);
        if (typeof raw === 'string' && raw.trim()) return [raw.trim()];
        return [];
      }

      function showToast(message) {
        toast.textContent = message;
        toast.classList.remove('show');
        void toast.offsetWidth;
        toast.classList.add('show');
      }

      function addEntity(initial = {}, locator) {
        const entity = { id: generateId(), ...structuredClone(defaultValues), ...initial };
        entity.entitytype = normalizeEntityType(entity.entitytype);
        entities.push(entity);
        renderEntityCard(entity, locator);
        if (!isBulkUpdating) {
          persistState();
          updateUI();
        }
        return entity;
      }

      function renderEntityCard(entity, locator) {
        const template = document.getElementById('entityTemplate');
        const fragment = template.content.cloneNode(true);
        const card = fragment.querySelector('.entity-card');
        card.dataset.id = entity.id;

        card.querySelector('[data-role="title"]').textContent = entity.name
          ? entity.name
          : '未命名衍生物';

        card.querySelectorAll('[data-field]').forEach((el) => {
          const field = el.dataset.field;
          const value = entity[field];
          if (field === 'entitytype' && el.multiple) {
            const selectedValues = Array.isArray(value) ? value : [];
            Array.from(el.options).forEach((option) => {
              option.selected = selectedValues.includes(option.value);
            });
          } else if (booleanFields.includes(field)) {
            el.value = value === true ? 'true' : value === false ? 'false' : '';
          } else {
            el.value = value ?? '';
          }
        });

        updateToggleButtonLabel(card);
        if (locator) {
          entitiesContainer.insertBefore(fragment, locator);
        } else {
          entitiesContainer.appendChild(fragment);
        }
      }

      function updateToggleButtonLabel(card) {
        if (!card) {
          return;
        }
        const toggleButton = card.querySelector('button[data-action="toggle"]');
        if (!toggleButton) {
          return;
        }
        toggleButton.textContent = card.classList.contains('collapsed') ? '展开' : '折叠';
      }

      function getEntityById(id) {
        return entities.find((entity) => entity.id === id);
      }

      function removeEntity(id) {
        const index = entities.findIndex((entity) => entity.id === id);
        if (index === -1) return;
        entities.splice(index, 1);
        const card = entitiesContainer.querySelector(`.entity-card[data-id="${id}"]`);
        card?.remove();
        if (!isBulkUpdating) {
          persistState();
          updateUI();
        }
      }

      function duplicateEntity(id) {
        const source = getEntityById(id);
        if (!source) return;
        const clone = structuredClone(source);
        clone.id = generateId();
        if (clone.name) {
          clone.name = `${clone.name} 副本`;
        }
        const anchor = entitiesContainer.querySelector(`.entity-card[data-id="${id}"]`);
        addEntity(clone, anchor?.nextSibling ?? null);
        showToast('已复制衍生物');
      }

      function toggleCard(id) {
        const card = entitiesContainer.querySelector(`.entity-card[data-id="${id}"]`);
        if (!card) return;
        card.classList.toggle('collapsed');
        updateToggleButtonLabel(card);
      }

      function collapseAll(state) {
        entitiesContainer.querySelectorAll('.entity-card').forEach((card) => {
          card.classList.toggle('collapsed', state);
          updateToggleButtonLabel(card);
        });
      }

      function handleFieldChange(target) {
        const card = target.closest('.entity-card');
        if (!card) return;
        const id = card.dataset.id;
        const entity = getEntityById(id);
        if (!entity) return;
        const field = target.dataset.field;
        const type = target.dataset.type;

        if (field === 'entitytype' && target instanceof HTMLSelectElement && target.multiple) {
          const selected = Array.from(target.selectedOptions).map((option) => option.value);
          entity.entitytype = selected;
        } else {
          let value = target.value;

          if (type === 'boolean') {
            if (value === 'true') value = true;
            else if (value === 'false') value = false;
            else value = null;
          }

          entity[field] = value;
        }

        if (field === 'name') {
          const title = card.querySelector('[data-role="title"]');
          title.textContent = entity.name ? entity.name : '未命名衍生物';
        }

        persistState();
        updateUI();
      }

      function parseList(raw) {
        if (!raw) return [];
        return raw
          .split(/[\n,，]/)
          .map((token) => token.trim())
          .filter(Boolean);
      }

      function escapeString(value) {
        return value
          .replace(/\\/g, '\\\\')
          .replace(/'/g, "\\'")
          .replace(/\r\n|\r|\n/g, '\\n');
      }

      function formatString(value) {
        return `'${escapeString(value)}'`;
      }

      function formatConstString(value) {
        return `'${escapeString(value)}' as const`;
      }

      function formatArray(list) {
        if (!list.length) return '';
        return `[${list.map((item) => formatString(item)).join(', ')}]`;
      }

      function formatConstArray(list) {
        if (!list.length) return '';
        return `${formatArray(list)} as const`;
      }

      function serializeValue(value, depth = 0) {
        if (value === undefined) {
          return undefined;
        }
        if (typeof value === 'string') {
          return `'${escapeString(value)}'`;
        }
        if (typeof value === 'number' || typeof value === 'boolean') {
          return String(value);
        }
        if (value === null) {
          return 'null';
        }
        const indent = '  '.repeat(depth);
        const nextIndent = '  '.repeat(depth + 1);
        if (Array.isArray(value)) {
          if (!value.length) return '[]';
          const items = value
            .map((item) => serializeValue(item, depth + 1))
            .filter((item) => item !== undefined);
          if (!items.length) return '[]';
          return `[\n${items.map((item) => `${nextIndent}${item}`).join(',\n')}\n${indent}]`;
        }
        if (typeof value === 'object') {
          const entries = Object.entries(value)
            .map(([key, val]) => {
              const serialized = serializeValue(val, depth + 1);
              if (serialized === undefined) return undefined;
              return `${nextIndent}${key}: ${serialized}`;
            })
            .filter(Boolean);
          if (!entries.length) return '{}';
          return `{\n${entries.join(',\n')}\n${indent}}`;
        }
        return undefined;
      }

      function stripComments(source) {
        let result = '';
        let i = 0;
        let inString = false;
        let stringQuote = '';
        let escaping = false;
        while (i < source.length) {
          const char = source[i];
          if (inString) {
            result += char;
            if (escaping) {
              escaping = false;
            } else if (char === '\\') {
              escaping = true;
            } else if (char === stringQuote) {
              inString = false;
            }
            i++;
            continue;
          }
          if (char === "'" || char === '"' || char === '`') {
            inString = true;
            stringQuote = char;
            result += char;
            i++;
            continue;
          }
          if (char === '/' && source[i + 1] === '/') {
            i += 2;
            while (i < source.length && source[i] !== '\n' && source[i] !== '\r') {
              i++;
            }
            continue;
          }
          if (char === '/' && source[i + 1] === '*') {
            i += 2;
            while (i < source.length && !(source[i] === '*' && source[i + 1] === '/')) {
              i++;
            }
            i += 2;
            continue;
          }
          result += char;
          i++;
        }
        return result;
      }

      function extractKeyBeforeBrace(source, braceIndex) {
        let i = braceIndex - 1;
        while (i >= 0 && /\s/.test(source[i])) {
          i--;
        }
        if (i < 0 || source[i] !== ':') {
          return null;
        }
        i--;
        while (i >= 0 && /\s/.test(source[i])) {
          i--;
        }
        if (i < 0) {
          return null;
        }
        let end = i + 1;
        let start = i;
        const quote = source[i];
        if (quote === '"' || quote === "'" || quote === '`') {
          i--;
          let escaped = false;
          while (i >= 0) {
            const char = source[i];
            if (escaped) {
              escaped = false;
            } else if (char === '\\') {
              escaped = true;
            } else if (char === quote) {
              start = i;
              break;
            }
            i--;
          }
          if (source[start] !== quote) {
            return null;
          }
          const raw = source.slice(start, end);
          return raw.slice(1, -1);
        }

        while (start >= 0 && !/[,\{\}\(\)\[\]\s]/.test(source[start])) {
          start--;
        }
        const raw = source.slice(start + 1, end);
        const trimmed = raw.trim();
        return trimmed || null;
      }

      function extractObjectLiteral(source) {
        const eqIndex = source.indexOf('=');
        let i = eqIndex !== -1 ? eqIndex + 1 : 0;
        let start = -1;
        let key = null;
        let depth = 0;
        let inString = false;
        let stringQuote = '';
        let escaping = false;
        while (i < source.length) {
          const char = source[i];
          if (inString) {
            if (escaping) {
              escaping = false;
            } else if (char === '\\') {
              escaping = true;
            } else if (char === stringQuote) {
              inString = false;
            }
            i++;
            continue;
          }
          if (char === "'" || char === '"' || char === '`') {
            inString = true;
            stringQuote = char;
            i++;
            continue;
          }
          if (char === '/' && source[i + 1] === '/') {
            i += 2;
            while (i < source.length && source[i] !== '\n' && source[i] !== '\r') {
              i++;
            }
            continue;
          }
          if (char === '/' && source[i + 1] === '*') {
            i += 2;
            while (i < source.length && !(source[i] === '*' && source[i + 1] === '/')) {
              i++;
            }
            i += 2;
            continue;
          }
          if (char === '{') {
            if (start === -1) start = i;
            if (depth === 0) {
              key = extractKeyBeforeBrace(source, i);
            }
            depth++;
            i++;
            continue;
          }
          if (char === '}') {
            if (depth > 0) depth--;
            i++;
            if (depth === 0 && start !== -1) {
              return { literal: source.slice(start, i), key };
            }
            continue;
          }
          i++;
        }
        return null;
      }

      function evaluateObjectLiteral(literal) {
        const cleaned = stripComments(literal).replace(/\bas const\b/g, '');
        try {
          const codeToEval = '"use strict"; return (' + cleaned + ');';
          const data = new Function(codeToEval)();
          if (!data || typeof data !== 'object') {
            throw new Error('对象解析结果无效');
          }
          return data;
        } catch (error) {
          console.error(error);
          throw new Error('无法解析代码片段，请确认语法无误。');
        }
      }

      function parseEntityDefinitions(raw) {
        let code = raw.trim();
        if (!code) {
          throw new Error('导入内容为空');
        }
        const directObject = code.startsWith('{') && code.endsWith('}');
        if (directObject) {
          return evaluateObjectLiteral(code);
        }

        const normalized = code
          .replace(/\bexport\s+default\b/g, '')
          .replace(/\bexport\s+const\b/g, 'const')
          .replace(/\bconst\s+([A-Za-z0-9_$]+)\s*:[^=]+=/g, 'const $1 =');

        let literalInfo = extractObjectLiteral(normalized);
        let literal = literalInfo ? literalInfo.literal : null;
        const inferredKey = literalInfo?.key;
        if (!literal) {
          literal = code.trim();
          if (!literal.startsWith('{')) {
            literal = `{${literal}}`;
          }
          const parsedObject = evaluateObjectLiteral(literal);
          return parsedObject;
        }

        const parsedObject = evaluateObjectLiteral(literal);

        if (
          inferredKey &&
          parsedObject &&
          typeof parsedObject === 'object' &&
          !Array.isArray(parsedObject) &&
          looksLikeEntityDefinition(parsedObject)
        ) {
          return { [inferredKey]: parsedObject };
        }

        return parsedObject;
      }

      function looksLikeEntityDefinition(obj) {
        const knownKeys = [
          'entitytype',
          'owner',
          'description',
          'detailedDescription',
          'create',
          'detailedCreate',
          'move',
          'gravity',
          'collsion',
          'aliases',
          'skills',
          'entityAttributesAsCharacter',
        ];

        return knownKeys.some((key) => Object.prototype.hasOwnProperty.call(obj, key));
      }

      function transformDefinitionToInitial(name, definition) {
        const entityTypes = normalizeEntityType(definition.entitytype);
        const normalizedTypes = entityTypes.length
          ? entityTypes
          : structuredClone(defaultValues.entitytype);
        const aliases = Array.isArray(definition.aliases) ? definition.aliases.filter(Boolean) : [];
        const collisions = Array.isArray(definition.collsion)
          ? definition.collsion.filter(Boolean)
          : typeof definition.collsion === 'string' && definition.collsion.trim()
            ? [definition.collsion.trim()]
            : [];
        const initial = {
          name,
          entitytype: normalizedTypes,
          factionId: definition.factionId ?? '',
          ownerName: definition.owner?.name ?? '',
          ownerType: definition.owner?.type ?? '',
          ownerFactionId: definition.owner?.factionId ?? '',
          aliasesInput: aliases.join(', '),
          collsionInput: collisions.join(', '),
          description: definition.description ?? '',
          detailedDescription: definition.detailedDescription ?? '',
          create: definition.create ?? '',
          detailedCreate: definition.detailedCreate ?? '',
          move: typeof definition.move === 'boolean' ? definition.move : null,
          gravity: typeof definition.gravity === 'boolean' ? definition.gravity : null,
          extraCode: '',
        };

        const handledKeys = new Set([
          'entitytype',
          'owner',
          'factionId',
          'aliases',
          'collsion',
          'description',
          'detailedDescription',
          'create',
          'detailedCreate',
          'move',
          'gravity',
          'imageUrl',
        ]);

        const extraLines = Object.entries(definition)
          .filter(([key, value]) => !handledKeys.has(key) && value !== undefined)
          .map(([key, value]) => {
            const serialized = serializeValue(value);
            if (!serialized) return null;
            return `${key}: ${serialized},`;
          })
          .filter(Boolean);

        if (extraLines.length) {
          initial.extraCode = extraLines.join('\n');
        }

        return initial;
      }

      function importEntitiesFromText(raw) {
        let parsed;
        try {
          parsed = parseEntityDefinitions(raw);
        } catch (error) {
          console.error(error);
          showToast((error && error.message) || '导入失败');
          return;
        }

        const entries = Object.entries(parsed);
        if (!entries.length) {
          showToast('未找到任何衍生物定义');
          return;
        }

        let count = 0;
        isBulkUpdating = true;
        try {
          entries.forEach(([entityName, definition]) => {
            if (!definition || typeof definition !== 'object') {
              return;
            }
            const normalizedName = String(entityName);
            const initial = transformDefinitionToInitial(normalizedName, definition);
            const existing = entities.find(
              (entity) => (entity.name ?? '').trim() === normalizedName.trim()
            );
            if (existing) {
              removeEntity(existing.id);
            }
            addEntity(initial);
            count++;
          });
        } finally {
          isBulkUpdating = false;
        }

        if (!count) {
          updateUI();
          showToast('未找到可导入的衍生物定义');
          return;
        }

        persistState();
        updateUI();
        if (importTextarea) {
          importTextarea.value = '';
        }
        showToast(`已导入 ${count} 个衍生物`);
      }

      function needsQuotes(name) {
        return !/^[$A-Za-z_\p{Letter}][\w\p{Letter}]*$/u.test(name);
      }

      function buildEntityEntry(entity, options = {}) {
        const { indent = 2, trailingComma = true } = options;
        const name = (entity.name ?? '').trim();
        if (!name) {
          return null;
        }
        const indentStr = ' '.repeat(indent);
        const innerIndent = ' '.repeat(indent + 2);
        const key = needsQuotes(name) ? `'${escapeString(name)}'` : name;
        const lines = [];

        const entityTypes = normalizeEntityType(entity.entitytype);
        if (entityTypes.length === 1) {
          lines.push(`${innerIndent}entitytype: ${formatConstString(entityTypes[0])},`);
        } else if (entityTypes.length > 1) {
          lines.push(`${innerIndent}entitytype: ${formatConstArray(entityTypes)},`);
        }

        if (entity.factionId) {
          lines.push(`${innerIndent}factionId: ${formatConstString(entity.factionId)},`);
        }

        const ownerName = (entity.ownerName ?? '').trim();
        const ownerType = (entity.ownerType ?? '').trim();
        const ownerFaction = (entity.ownerFactionId ?? '').trim();
        const hasOwnerName = !!ownerName;
        const hasOwnerType = !!ownerType;
        if (hasOwnerName || hasOwnerType || ownerFaction) {
          if (hasOwnerName && hasOwnerType) {
            const ownerParts = [
              `name: ${formatString(ownerName)}`,
              `type: ${formatConstString(ownerType)}`,
            ];
            if (ownerFaction) {
              ownerParts.push(`factionId: ${formatConstString(ownerFaction)}`);
            }
            lines.push(`${innerIndent}owner: { ${ownerParts.join(', ')} },`);
          }
        }

        const aliases = parseList(entity.aliasesInput);
        if (aliases.length) {
          lines.push(`${innerIndent}aliases: ${formatArray(aliases)},`);
        }

        const collisions = parseList(entity.collsionInput);
        if (collisions.length) {
          lines.push(`${innerIndent}collsion: ${formatArray(collisions)},`);
        }

        textFields.forEach((field) => {
          const value = entity[field];
          if (value) {
            lines.push(`${innerIndent}${field}: ${formatString(value)},`);
          }
        });

        booleanFields.forEach((field) => {
          const value = entity[field];
          if (value === true || value === false) {
            lines.push(`${innerIndent}${field}: ${value},`);
          }
        });

        const extraCode = entity.extraCode ?? '';
        if (extraCode.trim()) {
          extraCode.split(/\r?\n/).forEach((line) => {
            const trimmed = line.trim();
            if (!trimmed) return;
            lines.push(`${innerIndent}${trimmed}`);
          });
        }

        const body = lines.length ? `\n${lines.join('\n')}\n${indentStr}` : '';
        const suffix = trailingComma ? ',' : '';
        return `${indentStr}${key}: {${body}}${suffix}`;
      }

      function buildSnippet() {
        if (!entities.length) return '';
        return entities
          .map((entity) => buildEntityEntry(entity, { indent: 2, trailingComma: true }))
          .filter(Boolean)
          .join('\n\n');
      }

      async function exportSingleEntity(entity) {
        const snippet = buildEntityEntry(entity, { indent: 2, trailingComma: true });
        if (!snippet) {
          showToast('衍生物名称为空，无法导出');
          return;
        }
        const payload = `${snippet}\n`;
        const displayName = (entity.name ?? '').trim() || '衍生物';
        let success = false;
        try {
          await navigator.clipboard.writeText(payload);
          success = true;
        } catch (_) {
          let fallback = null;
          try {
            fallback = document.createElement('textarea');
            fallback.value = payload;
            fallback.style.position = 'fixed';
            fallback.style.opacity = '0';
            document.body.appendChild(fallback);
            fallback.focus();
            fallback.select();
            success = document.execCommand('copy');
          } catch (_) {
            success = false;
          } finally {
            if (fallback && fallback.parentNode) {
              fallback.parentNode.removeChild(fallback);
            }
          }
        }
        showToast(success ? `已导出 ${displayName}` : '导出失败，请重试');
      }

      function updateUI() {
        const snippet = buildSnippet();
        exportOutput.value = snippet;
        const total = entities.length;
        const missingName = entities.filter((entity) => !(entity.name ?? '').trim()).length;

        if (!total) {
          stats.textContent = '';
        } else {
          stats.textContent = `共 ${total} 个衍生物，其中 ${missingName} 个未命名`;
        }

        exportStatus.textContent = snippet
          ? `已生成 ${snippet.split('\n').length} 行代码`
          : '无可导出内容';
        emptyState.hidden = total !== 0;

        entitiesContainer.querySelectorAll('.entity-card').forEach((card) => {
          const entity = getEntityById(card.dataset.id);
          if (!entity) return;
          const nameMissing = !(entity.name ?? '').trim();
          const typeMissing = !normalizeEntityType(entity.entitytype).length;
          const ownerName = (entity.ownerName ?? '').trim();
          const ownerType = (entity.ownerType ?? '').trim();
          const ownerIncomplete = (ownerName && !ownerType) || (!ownerName && ownerType);
          card.classList.toggle('has-error', nameMissing || typeMissing || ownerIncomplete);
        });
      }

      function persistState() {
        const payload = entities.map(({ id, ...rest }) => ({ id, ...rest }));
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch (_) {
          /* 忽略存储异常 */
        }
      }

      function hydrateState() {
        let restored = null;
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (raw) restored = JSON.parse(raw);
        } catch (_) {
          restored = null;
        }
        if (Array.isArray(restored) && restored.length) {
          restored.forEach((entity) => addEntity(entity));
        } else {
          addEntity();
        }
      }

      entitiesContainer.addEventListener('input', (event) => {
        const target = event.target;
        if (target.matches('[data-field]')) {
          handleFieldChange(target);
        }
      });

      entitiesContainer.addEventListener('change', (event) => {
        const target = event.target;
        if (target.matches('[data-field]')) {
          handleFieldChange(target);
        }
      });

      entitiesContainer.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-action]');
        if (!button) return;
        const card = button.closest('.entity-card');
        if (!card) return;
        const id = card.dataset.id;
        const action = button.dataset.action;
        if (action === 'delete') {
          if (confirm('确认删除该衍生物吗？')) {
            removeEntity(id);
            showToast('已删除衍生物');
          }
        } else if (action === 'toggle') {
          toggleCard(id);
        } else if (action === 'duplicate') {
          duplicateEntity(id);
        } else if (action === 'export') {
          const entity = getEntityById(id);
          if (!entity) return;
          void exportSingleEntity(entity);
        }
      });

      document.getElementById('addEntity').addEventListener('click', () => {
        addEntity();
        showToast('已新增衍生物');
      });

      document.getElementById('emptyAdd').addEventListener('click', () => {
        addEntity();
        showToast('已新增衍生物');
      });

      document.getElementById('expandAll').addEventListener('click', () => {
        collapseAll(false);
      });

      document.getElementById('collapseAll').addEventListener('click', () => {
        collapseAll(true);
      });

      document.getElementById('resetAll').addEventListener('click', () => {
        if (!entities.length) return;
        if (!confirm('确认清空所有衍生物吗？此操作无法撤销。')) return;
        entities.length = 0;
        entitiesContainer.innerHTML = '';
        persistState();
        updateUI();
        showToast('已清空');
      });

      document.getElementById('copyBtn').addEventListener('click', async () => {
        const snippet = exportOutput.value.trim();
        if (!snippet) {
          showToast('没有可复制的内容');
          return;
        }
        try {
          await navigator.clipboard.writeText(snippet);
          showToast('已复制到剪贴板');
        } catch (_) {
          exportOutput.select();
          document.execCommand('copy');
          showToast('已复制（回退模式）');
        }
      });

      document.getElementById('downloadBtn').addEventListener('click', () => {
        const snippet = exportOutput.value.trim();
        if (!snippet) {
          showToast('没有可导出的内容');
          return;
        }
        const blob = new Blob([snippet], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const timestamp = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        const filename = `tjwiki-entities-${timestamp.getFullYear()}${pad(timestamp.getMonth() + 1)}${pad(timestamp.getDate())}-${pad(timestamp.getHours())}${pad(timestamp.getMinutes())}.txt`;
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        showToast('已下载 TXT 文件');
      });

      async function importAllEntitiesFromSite() {
        if (!importExistingBtn || importExistingBtn.dataset.loading === 'true') {
          return;
        }
        const originalLabel = importExistingBtn.textContent ?? '';
        importExistingBtn.dataset.loading = 'true';
        importExistingBtn.disabled = true;
        importExistingBtn.textContent = '导入中...';
        try {
          const response = await fetch('/api/entities/export', { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`请求失败 (${response.status})`);
          }
          const payload = await response.json();
          const definitions = payload?.entities;
          if (!definitions || typeof definitions !== 'object') {
            throw new Error('返回数据格式异常');
          }
          importEntitiesFromText(JSON.stringify(definitions, null, 2));
        } catch (error) {
          console.error(error);
          const message = error instanceof Error ? error.message : '未知错误';
          showToast(`导入失败: ${message}`);
        } finally {
          importExistingBtn.disabled = false;
          importExistingBtn.textContent = originalLabel;
          delete importExistingBtn.dataset.loading;
        }
      }

      function openPasteDialog() {
        if (importDialog && typeof importDialog.showModal === 'function') {
          if (importTextarea) {
            importTextarea.value = '';
          }
          importDialog.showModal();
          requestAnimationFrame(() => importTextarea?.focus());
        } else {
          const raw = window.prompt('请粘贴衍生物定义代码：');
          if (raw) {
            importEntitiesFromText(raw);
          }
        }
      }

      importPasteBtn?.addEventListener('click', () => {
        openPasteDialog();
      });

      importConfirm?.addEventListener('click', () => {
        const raw = importTextarea?.value ?? '';
        if (!raw.trim()) {
          showToast('导入内容为空');
          return;
        }
        if (importDialog?.open) {
          importDialog.close();
        }
        importEntitiesFromText(raw);
      });

      importCancel?.addEventListener('click', () => {
        if (importDialog?.open) {
          importDialog.close();
        }
      });

      importDialog?.addEventListener('close', () => {
        if (importTextarea) {
          importTextarea.value = '';
        }
      });

      importExistingBtn?.addEventListener('click', () => {
        void importAllEntitiesFromSite();
      });

      importFileBtn?.addEventListener('click', () => {
        importFileInput?.click();
      });

      importFileInput?.addEventListener('change', async (event) => {
        const input = event.target;
        if (!(input instanceof HTMLInputElement)) {
          return;
        }
        const file = input.files && input.files[0];
        if (!file) {
          return;
        }
        try {
          const text = await file.text();
          importEntitiesFromText(text);
        } catch (_) {
          showToast('读取文件失败');
        } finally {
          input.value = '';
        }
      });

      hydrateState();
      updateUI();
    </script>
  </body>
</html>
